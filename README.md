# Sandboxed Python Execution Library

`sandboxed_python` is a Rust library designed to execute Python code in a controlled, sandboxed environment from within a Rust application. Built on top of PyO3, it provides a secure and flexible way to run Python scripts while restricting access to potentially dangerous operations, such as file system manipulation or network requests. This library is particularly valuable for executing dynamically generated Python code—such as that produced by large language models (LLMs)—in a safe manner, without exposing the host system to risks.

## Table of Contents
- [Introduction](#introduction)
- [Features](#features)
- [Sandboxing Approach](#sandboxing-approach)
- [Installation](#installation)
- [Usage Examples](#usage-examples)
- [Basic Arithmetic Example](#basic-arithmetic-example)
- [Matplotlib Plotting Example](#matplotlib-plotting-example)
- [Context for LLM-Generated Code](#context-for-llm-generated-code)
- [Limitations](#limitations)
- [Contributing](#contributing)
- [License](#license)

## Introduction

The `sandboxed_python` library allows Rust developers to embed Python execution within their applications while enforcing strict security boundaries. By combining static code analysis with a restricted execution environment, it ensures that Python scripts can only perform approved operations, such as mathematical computations or data visualization, while blocking access to sensitive system resources.

This library is ideal for:
- Safely running Python code generated by LLMs or user inputs.
- Enabling scientific computing workflows with libraries like numpy and matplotlib.
- Providing a controlled environment for educational or experimental platforms.

## Features

- **Static Code Analysis**: Parses Python code to detect and block unauthorized imports or function calls before execution.
- **Restricted Execution Environment**: Limits Python's built-in capabilities to a safe subset, preventing access to dangerous functions.
- **Whitelisted Modules**: Supports pre-approved Python modules (e.g., numpy, matplotlib) for use in scripts.
- **In-Memory Output**: Allows data, such as plot images, to be returned to Rust without Python writing to the file system.
- **Cross-Platform Compatibility**: Runs on macOS, Linux, and Windows with proper configuration.

## Sandboxing Approach

The `sandboxed_python` library implements sandboxing through a two-pronged strategy that balances security and usability:

### Static Code Analysis:
- The Python code is parsed into an Abstract Syntax Tree (AST) using Python's ast module.
- The AST is analyzed to:
  - Verify that only whitelisted modules (e.g., numpy, matplotlib.pyplot) are imported.
  - Detect and block calls to blacklisted functions or methods (e.g., open, os.system, savefig).
- If any disallowed operations are found, execution is halted before the code runs.

### Restricted Execution Environment:
- A custom globals dictionary is provided, pre-loaded with only the whitelisted modules.
- The `__builtins__` dictionary is overridden to exclude hazardous built-in functions like `open`, `eval`, `exec`, and `compile`, while retaining `__import__` for approved imports.
- The Python code executes within this constrained context, ensuring it cannot access unauthorized resources like the file system or network.

> **Important Trade-Off**: This is not a "true" sandbox in the sense of full OS-level isolation (e.g., via containers or virtual machines). Instead, it relies on the Python interpreter installed on the user's machine. While this approach offers a good balance of security and simplicity, it means that a compromised or maliciously altered Python interpreter could potentially bypass the sandbox. For most practical applications, however, this provides sufficient protection with minimal complexity.

## Installation

### Prerequisites
- **Rust**: Install via rustup.
- **Python**: Version 3.** with development headers.
  - macOS: `brew install python@3.11`
  - Linux: `sudo apt-get install python3-dev`
  - Windows: Install from python.org with the "Development" option.
- **Python Packages**: Install required libraries:
  ```
  python3 -m pip install numpy matplotlib
  ```

### Building the Library
1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/sandboxed_python.git
   cd sandboxed_python
   ```

2. Set the Python executable (optional, required on some systems like macOS):
   ```bash
   export PYTHON_SYS_EXECUTABLE=/usr/local/bin/python3.11
   ```

3. Build the library:
   ```bash
   cargo build
   ```

## Usage Examples

The library includes two examples to illustrate its functionality:

### Basic Arithmetic Example

**File**: `examples/toy.rs`

**Run**: 
```bash
cargo run --example toy
```

**Description**: 
- Executes a Python script that uses numpy to compute the mean of an array (e.g., [1, 2, 3, 4, 5]).
- Returns the result to Rust, which prints it to the console.

**Purpose**: Demonstrates simple computation with a whitelisted module in a sandboxed environment.

### Matplotlib Plotting Example

**File**: `examples/plot.rs`

**Run**: 
```bash
cargo run --example plot
```

**Description**: 
- Executes Python code that generates a sine wave plot using matplotlib.
- Saves the plot to an in-memory buffer as PNG bytes, which are returned to Rust.
- Rust writes the bytes to a file (sine_wave.png) on the host system.

**Purpose**: Shows how to handle graphical output securely without allowing Python to access the file system directly.

## Context for LLM-Generated Code

Large language models (LLMs) often generate Python code for tasks like data analysis, visualization, or automation. However, executing this code directly can be risky due to potential security threats (e.g., deleting files, making network requests). The `sandboxed_python` library addresses this by:

- **Restricting Capabilities**: Only whitelisted modules (e.g., numpy, matplotlib) are accessible, and dangerous operations are blocked.
- **Safe Data Handling**: Outputs like plot images are processed in-memory and returned to Rust, avoiding file system risks in Python.
- **Ease of Integration**: Seamlessly embeds Python execution in Rust-based LLM agents or tools.

This makes it well-suited for:
- AI-driven data analysis platforms.
- Educational tools accepting user or AI-generated scripts.
- Scientific workflows requiring both security and Python's computational strengths.

While not a fully isolated sandbox (due to its reliance on the local Python installation), it strikes a practical trade-off between security, performance, and ease of use for most applications.

## Limitations

- **Interpreter Dependency**: Security depends on the integrity of the user's Python installation; a compromised interpreter could bypass restrictions.
- **Fixed Whitelist**: Only pre-approved modules are allowed, requiring manual updates to support additional libraries.
- **Overhead**: Static analysis and restricted execution add minor performance costs, though these are typically negligible.

## Contributing

We welcome contributions! Please submit issues or pull requests to the GitHub repository.

